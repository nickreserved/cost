<?php
require_once('basic.php');
require_once('unserialize.php');
require_once('functions.php');

/** Παίρνει μια χρονική στιγμή σε κείμενο και επιστρέφει timestamp.
 * @param string|int $a Ημερομηνία της μορφής '31 23:59 Δεκ 19' κατά την είσοδο και timestamp μετά
 * την έξοδο */
function make_it_timestamp(& $a) {
	$a = parse_datetime($a);
	$a = mktime($a[1], $a[2], 0, $a[3], $a[0], $a[4]);
}

/** Παίρνει μια χρονική στιγμή σε κείμενο και αν υπάρχει, επιστρέφει timestamp.
 * Με την επιστροφή της συνάρτησης το στοιχείο $ar[$key] έχει το timestamp της δοσμένης χρονικής στιγμής.
 * @param array $ar Ένα array με κάποιο στοιχείο του να είναι το κείμενο με τη χρονική στιγμή της
 * μορφής '31 23:59 Δεκ 19'
 * @param string|int $key Το κλειδί του στοιχείου του array */
function make_it_timestamp_if_exists(& $ar, $key) {
	if (isset($ar[$key])) make_it_timestamp($ar[$key]);
}

/** Χωρίζει ένα κείμενο με βάση κάποιο άλλο κείμενο.
 * @param string $s Το κείμενο που θα κομματιαστεί
 * @param string $c Το κείμενο που σηματοδοτεί ένα νέο κόμματι
 * @return array Τα τμήματα που προέκυψαν από το αρχικό κείμενο, δίχως κενούς χαρακτήρες στα άκρα τους */
function explodetrim($s, $c) { return array_map(function($a) { return trim($a); }, explode($c, $s)); }

/** Χωρίζει ένα κείμενο με βάση το χαρακτήρα '&'.
 * @param string $s Το κείμενο που θα κομματιαστεί. Επιστρέφεται array με τα τμήματα που προέκυψαν
 * από το αρχικό κείμενο, δίχως κενούς χαρακτήρες στα άκρα τους */
function string_to_array(& $s) { $s = explodetrim($s, '&'); }

/** Χωρίζει ένα κείμενο με βάση το χαρακτήρα '&'.
 * Με την επιστροφή της συνάρτησης το στοιχείο $ar[$key] έχει το array με τα τμήματα που προέκυψαν
 * από το αρχικό κείμενο, δίχως κενούς χαρακτήρες στα άκρα τους.
 * @param array $ar Ένα array με κάποιο στοιχείο του να είναι το κείμενο που θα κομματιαστεί
 * @param string|int $key Το κλειδί του στοιχείου του array */
function element_to_array(& $ar, $key) {
	if (isset($ar[$key])) $ar[$key] = explodetrim($ar[$key], '&');
}

/** Επιστρέφει τους μειοδότες.
 * Έχει εφαρμογή μόνο αν ο διαγωνισμός δεν γίνεται κατά είδος.
 * <p>Αν είναι πάνω από ένας (έχουν δώσει ίδια τιμή) ο διαγωνισμός πρέπει να
 * επαναληφθεί.
 * @return array Ενδιαφερόμενοι που μειοδότησαν */
function unseal_equal_offers($accepted_competitors) {
	$min = min(array_map(function($i) { return $i['Προσφορά']; }, $accepted_competitors));
	$accepted_competitors = array_filter($accepted_competitors,
			function($i) use($min) { return $i['Προσφορά'] == $min; });
	return array_values($accepted_competitors);
}

/** Ενσωματώνει στα δεδομένα, λίστα με τα ονόματα όλων των επιμέρους κρατήσεων, όλων των τιμολογίων.
 * Μια λίστα με τα ονόματα όλων των επιμέρους κρατήσεων όλων των τιμολογίων αποθηκεύεται στο πεδίο
 * $data['Κρατήσεις']. */
function init_deduction_names() {
	global $data;
	$a = array();
	foreach($data['Τιμολόγια'] as $invoice) {
		$deduction = $invoice['Κρατήσεις'];
		if ($deduction)
			foreach(array_keys($deduction) as $v)
				if (!in_array($v, $a)) $a[] = $v;
	}
	$data['Κρατήσεις'] = $a;
}

/** Προετοιμάζει τους διαγωνισμούς.
 * Ελέγχει οι διαγωνιζόμενοι να είναι τουλάχιστον τρείς.
 * <p>Ορίζει το timestamp της έναρξης του διαγωνισμού από το χρόνο έναρξης του διαγωνισμού.
 * <p>Ορίζει τον τίτλο του διαγωνισμού, αν δεν έχει οριστεί, από τον τίτλο της δαπάνης. */
function init_tenders() {
	global $data;
	if (!isset($data['Διαγωνισμοί'])) return;
	foreach($data['Διαγωνισμοί'] as & $tender) {
		// Τα κενά πεδία των διαγωνισμών συμπληρώνονται
		if (!isset($tender['Τίτλος'])) $tender['Τίτλος'] = $data['Τίτλος'];
		if ($tender['Τύπος'] != 'Συνοπτικός Διαγωνισμός')
			trigger_error('Υποστηρίζονται μόνο συνοπτικοί διαγωνισμοί (προς το παρόν)', E_USER_ERROR);
		//Timestamps
		make_it_timestamp($tender['Χρόνος Αποσφράγισης Προσφορών']);
		make_it_timestamp_if_exists($tender, 'Χρόνος Αποσφράγισης Οικονομικών Προσφορών');
		make_it_timestamp_if_exists($tender, 'Χρόνος Κατάθεσης Δικαιολογητικών Κατακύρωσης');
		// Τα δικαιολογητικά διαχωρίζονται
		string_to_array($tender['Δικαιολογητικά Συμμετοχής']);
		foreach($tender['Ενδιαφερόμενοι'] as & $competitor) {
			element_to_array($competitor, 'Δικαιολογητικά Συμμετοχής');
			element_to_array($competitor, 'Λόγοι Απόρριψης Συμμετοχής');
			if (isset($competitor['Προσφορά ή Απόρριψη'])) {
				$m = $competitor['Προσφορά ή Απόρριψη'];
				if (is_numeric($m)) $competitor['Προσφορά'] = $m;
				else $competitor['Λόγοι Απόρριψης Οικονομικής Προσφοράς'] = explodetrim($m, '&');
				unset($competitor['Προσφορά ή Απόρριψη']);
			}
		}
		element_to_array($tender, 'Δικαιολογητικά Κατακύρωσης');
	}
}

/** Προετοιμάζει τις συμβάσεις.
 * Σε διαγωνισμούς, ο νικητής ορίζεται με index στη λίστα διαγωνιζόμενων. Αυτό απαιτεί τροποποίηση.
 * <p>Ορίζει τον τίτλο της σύμβασης αν δεν έχει τεθεί, πρώτα από τον τίτλο του διαγωνισμού στον
 * οποίο ανήκει η σύμβαση (αν ανήκει) και αν δεν έχει οριστεί ούτε αυτός, από τον τίτλο της δαπάνης.
 * <p>Πρέπει να κληθεί μετά από την init_tenders(). */
function init_contracts() {
	global $data;
	if (!isset($data['Συμβάσεις'])) return;
	foreach($data['Συμβάσεις'] as & $contract) {
		$title = $data['Τίτλος'];		// fallback 2 για τον τίτλο της σύμβασης
		if (isset($contract['Διαγωνισμός'])) {
			$tender = $contract['Διαγωνισμός'] = $data['Διαγωνισμοί'][$contract['Διαγωνισμός']];
			$title = $tender['Τίτλος']; // fallback 1 για τον τίτλο της σύμβασης
			// Σε διαγωνισμό, ο δικαιούχος αποθηκευέται σαν index
			if (isset($contract['Ανάδοχος']))
				$contract['Ανάδοχος'] = $tender['Ενδιαφερόμενοι'][$contract['Ανάδοχος']]['Ενδιαφερόμενος'];
		}
		// Τα κενά πεδία των συμβάσεων συμπληρώνονται
		if (!isset($contract['Τίτλος'])) $contract['Τίτλος'] = $title;
		// Timestamp σύμβασης
		if (isset($contract['Σύμβαση'])) {
			$name = $contract['Σύμβαση'];
			$a = null;
			if (preg_match('/\d+\/(\d{1,2})-(\d{1,2})-(\d{4})/', $name, $a)
					&& checkdate($a[2], $a[1], $a[3]))
				$contract['Χρόνος Υπογραφής Σύμβασης'] = mktime(14, 20, 0, $a[2], $a[1], $a[3]);
			else
				trigger_error(($name ? "Το '<b>$name</b>' δεν είναι ταυτότητα σύμβασης"
						: 'Η ταυτότητα σύμβασης πρέπει να δίνεται') . ' στη μορφή 132/31-12-2019 (αρ. πρωτοκόλλου/ημερομηνία)');
		}
	}
}

/** Ενσωματώνει στα τιμολόγια τις αξίες του τιμολογίου.
 * Στο πεδίο 'Τιμές', αποθηκεύεται ένα array με στοιχεία που έχουν κλειδιά 'Καθαρή Αξία', 'ΦΠΑ',
 * 'Καταλογιστέο', 'Κρατήσεις', 'Πληρωτέο', 'Καθαρή Αξία για ΦΕ', 'ΦΕ', 'Υπόλοιπο Πληρωτέο', με την
 * αντίστοιχη τιμή για το καθένα.
 * <p>Το παραπάνω συμβαίνει και στο πεδίο $data['Τιμές'], αθροιστικά για όλα τα τιμολόγια.
 * <p>Στο πεδίο 'Κατηγορίες ΦΠΑ' αποθηκεύονται ως κλειδιά τα διαφορετικά ποσοστά ΦΠΑ του τιμολογίου
 * και ως τιμές, οι αντίστοιχες αξίες του ΦΠΑ σε €.
 * <p>Αν το τιμολόγιο ανήκει σε σύμβαση, στο πεδίο 'Δικαιούχος', αποθηκεύεται το πεδίο 'Ανάδοχος'
 * της σύμβασης.
 * <p>Στα είδη τιμολογίου, στο πεδίο 'Συνολική Τιμή', αποθηκεύεται το γινόμενο ποσότητας είδους επί
 * της καθαρής αξίας του ενός είδους.
 * <p>Στις κρατήσεις, στο πεδίο 'Σύνολο', αποθηκεύεται το σύνολο των επιμέρους κρατήσεων της κράτησης.
 * <p>Πρέπει να κληθεί μετά από την init_deduction_names() και την init_contracts(). */
function init_invoices() {
	global $data;
	foreach($data['Τιμολόγια'] as & $invoice) {
		// Αρχικοποιεί σύμβαση και δικαιούχο
		if (isset($invoice['Σύμβαση'])) {
			$invoice['Σύμβαση'] = $data['Συμβάσεις'][$invoice['Σύμβαση']];
			$invoice['Δικαιούχος'] = $invoice['Σύμβαση']['Ανάδοχος'];
		}
		// Ενσωματώνει στις κρατήσεις των τιμολογίων το άθροισμα των επιμέρους κρατήσεών τους.
		$deduction = & $invoice['Κρατήσεις'];
		if (!$deduction) $invoice['Κρατήσεις'] = array('Σύνολο' => 0);
		else {
			$sum = 0;
			foreach($deduction as $v)
				$sum += $v;
			$deduction['Σύνολο'] = round($sum, 5);
		}
		// Ενσωματώνει το πεδίο 'Συνολική Τιμή' σε κάθε είδος τιμολογίου
		// Υπολογίζει καθαρή αξία και ΦΠΑ τιμολογίου καθώς και τυχόν κατηγορίες ΦΠΑ
		$net = $vat = 0;
		$vat_categories = array();
		foreach($invoice['Είδη'] as & $item) {
			$a = round($item['Τιμή Μονάδας'] * $item['Ποσότητα'], 3);
			$item['Συνολική Τιμή'] = $a;
			$net += $a;
			$vat_p = $item['ΦΠΑ'];
			if ($vat_p) {
				$a *= $vat_p / 100;
				$vat += $a;
				if (isset($vat_categories[$vat_p])) $vat_categories[$vat_p] += $a;
				else $vat_categories[$vat_p] = $a;
			}
		}
		// Ενσωματώνει τις αξίες του τιμολογίου σε κάθε τιμολόγιο
		$net = round($net, 2);
		$vat = round($vat, 2);
		$vat_categories = adjust_partials($vat_categories, $vat);
		$mixed = $net + $vat;
		$deductions = round($net * $invoice['Κρατήσεις']['Σύνολο'] / 100, 2);
		$contractor_type = $invoice['Δικαιούχος']['Τύπος'];
		if ($contractor_type != 'Ιδιωτικός Τομέας') $mixed += $deductions;
		$mixed = round($mixed, 2);
		$payable = round($mixed - $deductions, 2);
		$netIncomeTax = $net;
		$incomeTax = $invoice['ΦΕ'];
		if ($incomeTax != 3) $netIncomeTax -= $deductions;
		$netIncomeTax = round($netIncomeTax, 2);
		$incomeTax = round($netIncomeTax * $incomeTax / 100, 2);
		$payableMinusIncomeTax = round($payable - $incomeTax, 2);
		$invoice['Τιμές'] = array(
			'Καθαρή Αξία'        => $net,
			'ΦΠΑ'                => $vat,
			'Καταλογιστέο'       => $mixed,
			'Κρατήσεις'          => $deductions,
			'Πληρωτέο'           => $payable,
			'Καθαρή Αξία για ΦΕ' => $netIncomeTax,
			'ΦΕ'                 => $incomeTax,
			'Υπόλοιπο Πληρωτέο'  => $payableMinusIncomeTax
		);
		$invoice['Κατηγορίες ΦΠΑ'] = $vat_categories;
	}
	// Υπολογισμός καταλογιστέου, κρατήσεων, ΦΕ, κτλ για το σύνολο της δαπάνης
	$data['Τιμές'] = calc_sum_of_invoices_prices($data['Τιμολόγια']);
}

/** Ενσωματώνει στα δεδομένα την πιο πρόσφατη ημερομηνία τιμολογίου.
 * Στο πεδίο $data['Ημερομηνία Τελευταίου Τιμολογίου'], αποθηκεύεται η παραπάνω ημερομηνία σε
 * timestamp. */
function init_newer_invoice_date() {
	global $data;
	$a = get_newer_invoice_timestamp($data['Τιμολόγια']);
	if ($a) $data['Ημερομηνία Τελευταίου Τιμολογίου'] = $a;
}

/** Ενσωματώνει στα δεδομένα ένα array με τις λίστες τιμολογίων του κάθε δικαιούχου.
 * Στο πεδίο $data['Δικαιούχοι'], αποθηκεύονται στοιχεία για κάθε δικαιούχο.
 * <p>Κάθε στοιχείο δικαιούχου, περιέχει τα εξής στοιχεία:
 * <ul><li>Με κλειδί 'Τιμολόγια' array με τα τιμολόγια του δικαιούχου.
 * <li>Με κλειδί 'Τιμές' τα αθροίσματα των αντίστοιχων αξιών των τιμολογίων του δικαιούχου.
 * <li>Με κλειδί 'Δικαιούχος' τα στοιχεία του δικαιούχου.
 * <li>Με κλειδί 'Σύμβαση' τη σύμβαση με το δικαιούχο, αν υπάρχει.
 * <li>Με κλειδί 'Διαγωνισμός' το διαγωνισμό στον οποίο συμμετείχε ο δικαιούχος, αν συμμετείχε.</ul>
 * <p>Επίσης ελέγχει αν τα τιμολόγια του ίδιου δικαιούχου ανήκουν στην ίδια σύμβαση. Αν ένας
 * δικαιούχος έχει υπογράψει σύμβαση μαζί μας, όλα τα τιμολόγια που έχει εκδόσει πρέπει να ανήκουν
 * σε αυτή τη σύμβαση. Αν δεν έχει υπογράψει, δεν πρέπει κανένα τιμολόγιο να ανήκει σε αυτή τη σύμβαση.
 * <p>Πρέπει να κληθεί μετά από την init_invoices(). */
function init_by_contractor() {
	global $data;
	// Τιμολόγια κατά δικαιούχο: Επιστρέφει ένα array με ένα στοιχείο για κάθε δικαιούχο,
	// που περιέχει ένα array με όλα τα τιμολόγια του δικαιούχου
	$b = array();
	foreach($data['Τιμολόγια'] as $invoice)
		$b[$invoice['Δικαιούχος']['Επωνυμία']][] = $invoice;
	$data['Δικαιούχοι'] = array_values($b);
	// Απαρίθμηση του κάθε δικαιούχου για να προστεθούν επιπλέον πεδία
	foreach($data['Δικαιούχοι'] as & $per_contractor) {
		// Υπολογισμός αξιών για όλη την ομάδα τιμολογίων και λοιπές συντομεύσεις
		$invoice = $per_contractor[0];
		$per_contractor = array(
			'Τιμολόγια' => $per_contractor,
			'Τιμές' => calc_sum_of_invoices_prices($per_contractor),
			'Δικαιούχος' => $invoice['Δικαιούχος']);
		// Δημιουργεί συντόμευση σύμβασης, αν υπάρχει, από το πρώτο τιμολόγιο, και επιπλέον...
		if (isset($invoice['Σύμβαση'])) {
			$contract = $invoice['Σύμβαση'];
			// ...όλα τα τιμολόγια του ίδιου δικαιούχου πρέπει να έχουν την ίδια σύμβαση
			$per_contractor['Σύμβαση'] = $contract;
			foreach($per_contractor['Τιμολόγια'] as $invoice)
				if (!isset($invoice['Σύμβαση']) || $contract !== $invoice['Σύμβαση'])
					trigger_error("Δεν ανήκουν όλα τα τιμολόγια του «{$invoice['Δικαιούχος']['Επωνυμία']}» στην ίδια σύμβαση");
			// Δημιουργεί συντόμευση διαγωνισμού, αν υπάρχει
			if (isset($contract['Διαγωνισμός'])) $per_contractor['Διαγωνισμός'] = $contract['Διαγωνισμός'];
		} else	// Αν δεν υπάρχει σύμβαση στο πρώτο τιμολόγιο, κανένα τιμολόγιο δεν πρέπει να έχει
			foreach($per_contractor['Τιμολόγια'] as $invoice)
				if (isset($invoice['Σύμβαση']))
					trigger_error("Δεν ανήκουν όλα τα τιμολόγια του «{$invoice['Δικαιούχος']['Επωνυμία']}» στην ίδια σύμβαση");
	}
}

/** Ενσωματώνει στα δεδομένα ένα array με τις λίστες τιμολογίων της κάθε σύμβασης.
 * Στο πεδίο $data['Συμβάσεις'], αποθηκεύονται στοιχεία για κάθε σύμβαση.
 * <p>Κάθε στοιχείο σύμβασης, περιέχει τα εξής στοιχεία:
 * <ul><li>Με κλειδί 'Τιμολόγια' array με τα τιμολόγια της σύμβασης.
 * <li>Με κλειδί 'Τιμές' τα αθροίσματα των αντίστοιχων αξιών των τιμολογίων της σύμβασης.
 * <li>Με κλειδί 'Δικαιούχος' τα στοιχεία του δικαιούχου.
 * <li>Με κλειδί 'Σύμβαση' τη σύμβαση με το δικαιούχο.
 * <li>Με κλειδί 'Διαγωνισμός' το διαγωνισμό στον οποίο ανήκει η σύμβαση, αν ανήκει.</ul>
 * <p>Επίσης ελέγχει αν υπάρχουν συμβάσεις δίχως τιμολόγια.
 * <p>Πρέπει να κληθεί μετά από την init_invoices(). */
function init_by_contract() {
	global $data;
	if (!isset($data['Συμβάσεις'])) return;
	// Τιμολόγια κατά σύμβαση: Επιστρέφει ένα array με ένα στοιχείο για κάθε σύμβαση, που περιέχει
	// ένα array με όλα τα τιμολόγια της σύμβασης
	$contracts = array();
	foreach($data['Τιμολόγια'] as $invoice)
		if (isset($invoice['Σύμβαση'])) {
			// Δυστυχώς δεν μπορούν να υπάρξουν array ως κλειδιά
			// Έλεγχος αν υπάρχει η σύμβαση.
			foreach($contracts as & $per_contract)
				if ($per_contract[0]['Σύμβαση'] == $invoice['Σύμβαση']) {
					$per_contract[] = $invoice;
					continue 2;
				}
			// Δε βρέθηκε ομάδα τιμολογίων γι' αυτή τη σύμβαση
			$contracts[][] = $invoice;
		}
	// Απαρίθμηση της κάθε σύμβασης για να προστεθούν επιπλέον πεδία
	foreach($contracts as & $per_contract) {
		// Υπολογισμός αξιών για όλη την ομάδα τιμολογίων και λοιπές συντομεύσεις
		$invoice = $per_contract[0];
		$contract = $invoice['Σύμβαση'];
		$contractor = $invoice['Δικαιούχος'];
		$per_contract = array(
			'Τιμολόγια' => $per_contract,
			'Τιμές' => calc_sum_of_invoices_prices($per_contract),
			'Δικαιούχος' => $contractor,
			'Σύμβαση' => $contract);
		if (isset($contract['Διαγωνισμός'])) {
			// Δημιουργεί συντόμευση διαγωνισμού, αν υπάρχει
			$tender = $contract['Διαγωνισμός'];
			$per_contract['Διαγωνισμός'] = $tender;
			// Η οικονομικότερη προσφορά στο διαγωνισμό πρέπει να συμπίπτει με το καταλογιστέο της
			// σύμβασης και ο ενδιαφερόμενος που την κάνει πρέπει να είναι ο ανάδοχος της σύμβασης
			if (!$tender['Προσφορά κατά είδος']) {
				$competitors = array_filter($tender['Ενδιαφερόμενοι'],
						// Επιλογή των ενδιαφερόμενων που δεν απορρίφθηκαν
						function($competitor) {
							return !isset($competitor['Λόγοι Απόρριψης Συμμετοχής'])
									&& !isset($competitor['Λόγοι Απόρριψης Οικονομικής Προσφοράς']);
						});
				if (count($competitors))
					$competitors = unseal_equal_offers($competitors);
				if (count($competitors)) {
					$contractors = array_map(function($i) { return $i['Ενδιαφερόμενος']; }, $competitors);
					if (!in_array($contractor, $contractors))
						trigger_error('Ανάδοχος δεν έχει τη χαμηλότερη προσφορά στο διαγωνισμό');
					if ($competitors[0]['Προσφορά'] != $per_contract['Τιμές']['Καταλογιστέο'])
						trigger_error('Προσφορά αναδόχου δε συμπίπτει με το καταλογιστέο της σύμβασης');
				}
			}
		}
	}
	// Πρέπει όλες οι συμβάσεις να χρησιμοποιούνται απο τιμολόγια
	if (count($contracts) != count($data['Συμβάσεις']))
		trigger_error('Υπάρχουν συμβάσεις που δεν χρησιμοποιούνται από κανένα τιμολόγιο');
	// Απόδοση των δεδομένων
	$data['Συμβάσεις'] = $contracts;
}

/** Ενσωματώνει στα δεδομένα ένα array με τις λίστες τιμολογίων και συμβάσεων του κάθε διαγωνισμού.
 * Στο πεδίο $data['Διαγωνισμοί'], αποθηκεύονται στοιχεία για κάθε διαγωνισμό.
 * <p>Κάθε στοιχείο διαγωνισμού, περιέχει τα εξής στοιχεία:
 * <ul><li>Με κλειδί 'Τιμολόγια' array με τα τιμολόγια του διαγωνισμού.
 * <li>Με κλειδί 'Τιμές' τα αθροίσματα των αντίστοιχων αξιών των τιμολογίων του διαγωνισμού.
 * <li>Με κλειδί 'Συμβάσεις' τις συμβάσεις που προέκυψαν από το διαγωνισμό.
 * <li>Με κλειδί 'Διαγωνισμός' το διαγωνισμό.</ul>
 * <p>Επίσης ελέγχει αν υπάρχουν διαγωνισμοί δίχως συμβάσεις.
 * <p>Πρέπει να κληθεί μετά από την init_by_contract(). */
function init_by_tender() {
	global $data;
	if (!isset($data['Διαγωνισμοί'])) return;
	// Συμβάσεις κατά διαγωνισμό: Επιστρέφει ένα array με ένα στοιχείο για κάθε διαγωνισμό, που
	// περιέχει ένα array με όλες τις συμβάσεις του διαγωνισμού
	$tenders = array();
	foreach($data['Συμβάσεις'] as $per_contract)
		if (isset($per_contract['Διαγωνισμός'])) {
			// Δυστυχώς δεν μπορούν να υπάρξουν array ως κλειδιά
			// Έλεγχος αν υπάρχει ο διαγωνισμός.
			foreach($tenders as & $per_tender)
				if ($per_tender[0]['Διαγωνισμός'] == $per_contract['Διαγωνισμός']) {
					$per_tender[] = $per_contract;
					continue 2;
				}
			// Δε βρέθηκε ο διαγωνισμός
			$tenders[][] = $per_contract;
		}
	// Απαρίθμηση του κάθε διαγωνισμού για να προστεθούν επιπλέον πεδία
	foreach($tenders as & $per_tender) {
		// Υπολογισμός αξιών για όλη την ομάδα τιμολογίων και λοιπές συντομεύσεις
		$invoices = array_reduce($per_tender, function($p, $i) { return array_merge($p, $i['Τιμολόγια']); }, array());
		$contracts = array_map(function($a) { return $a['Σύμβαση']; }, $per_tender);
		$per_tender = array(
			'Τιμολόγια' => $invoices,
			//TODO: 'Τιμές' => calc_sum_of_invoices_prices($invoices),
			'Συμβάσεις' => $contracts,
			'Διαγωνισμός' => $contracts[0]['Διαγωνισμός']);
		// Timestamp νεότερης σύμβασης
		$a = get_newer_contract_timestamp($contracts);
		if (isset($a)) $per_tender['Χρόνος Υπογραφής Συμβάσεων'] = $a;
		// Διαγωνισμοί με περισσότερες τις μια συμβάσεις, πρέπει να είναι κατά είδος
		if (count($contracts) > 1 && !$per_tender['Διαγωνισμός']['Προσφορά κατά είδος'])
			trigger_error('Διαγωνισμός με πάνω από μια σύμβαση, χωρίς "Προσφορά κατά είδος"');
	}
	// Πρέπει όλοι οι διαγωνισμοί να χρησιμοποιούνται απο συμβάσεις
	if (count($tenders) != count($data['Διαγωνισμοί']))
		trigger_error('Υπάρχουν διαγωνισμοί που δεν χρησιμοποιούνται από καμία σύμβαση');
	// Απόδοση των δεδομένων
	$data['Διαγωνισμοί'] = $tenders;
}

init_deduction_names();
init_tenders();
init_contracts();
init_invoices();
init_newer_invoice_date();
init_by_contractor();
init_by_contract();
init_by_tender();